import {TaskError, type Task} from '@fuzdev/gro';
import {z} from 'zod';
import {readFile, writeFile} from 'node:fs/promises';
import {format_file} from '@fuzdev/gro/format_file.js';
import {basename, resolve} from 'node:path';
import {print_path} from '@fuzdev/gro/paths.js';
import {load_from_env} from '@fuzdev/gro/env.js';
import {package_json_load} from '@fuzdev/gro/package_json.js';
import {existsSync} from 'node:fs';

import {fetch_repo_data} from './fetch_repo_data.js';
import {create_fs_fetch_value_cache} from './fs_fetch_value_cache.js';
import {get_gitops_ready} from './gitops_task_helpers.js';
import {GITOPS_CONFIG_PATH_DEFAULT} from './gitops_constants.js';

// TODO add flag to ignore or invalidate cache -- no-cache? clean?

/** @nodocs */
export const Args = z.strictObject({
	config: z
		.string()
		.meta({description: 'path to the gitops config file, absolute or relative to the cwd'})
		.default(GITOPS_CONFIG_PATH_DEFAULT),
	dir: z
		.string()
		.meta({description: 'path containing the repos, defaults to the parent of the config dir'})
		.optional(),
	outdir: z
		.string()
		.meta({description: 'path to the directory for the generated files, defaults to $routes/'})
		.optional(),
	download: z.boolean().meta({description: 'download all missing local repos'}).default(false),
	check: z
		.boolean()
		.meta({description: 'check repos are ready without fetching remote data'})
		.default(false),
});
export type Args = z.infer<typeof Args>;

/**
 * This is a task not a `.gen.` file because it makes network calls.
 *
 * @nodocs
 */
export const task: Task<Args> = {
	Args,
	summary: 'syncs local repos and generates UI data from repo metadata',
	run: async ({args, log, svelte_config, invoke_task}) => {
		const {config, dir, outdir = svelte_config.routes_path, download, check} = args;

		const {local_repos} = await get_gitops_ready({config, dir, download, log});

		const outfile_json = resolve(outdir, 'repos.json');
		const outfile_ts = resolve(outdir, 'repos.ts');

		// This searches the parent directory for the env var, so we don't use SvelteKit's $env imports
		const token = load_from_env('SECRET_GITHUB_API_TOKEN');
		if (!token) {
			throw new TaskError('the env var SECRET_GITHUB_API_TOKEN was not found');
		}

		// Exit early if only checking repo readiness
		if (check) {
			log.info('repos are ready');
			return;
		}

		const cache = await create_fs_fetch_value_cache('repos');

		log.info('fetching remote repo data');
		const repos_json = await fetch_repo_data(local_repos, token, cache.data, log);

		// TODO should package_json be provided in the Gro task/gen contexts? check if it's always loaded
		const package_json = await package_json_load();
		const repo_specifier =
			package_json.name === '@fuzdev/fuz_gitops'
				? '$lib/repo.svelte.js'
				: '@fuzdev/fuz_gitops/repo.svelte.js';

		log.info(`generating ${outfile_json} and ${outfile_ts}`);

		// Generate repos.json with the raw data
		const json_contents = await format_file(JSON.stringify(repos_json), {filepath: outfile_json});
		const existing_json = existsSync(outfile_json) ? await readFile(outfile_json, 'utf8') : '';
		const json_changed = existing_json !== json_contents;
		if (json_changed) {
			log.info(`writing changes to ${print_path(outfile_json)}`);
			await writeFile(outfile_json, json_contents);
		} else {
			log.info(`no changes to ${print_path(outfile_json)}`);
		}

		// Generate repos.ts that imports from repos.json
		// TODO the `basename` is used here because we don't have an `origin_id` like with gen,
		// and this file gets re-exported,
		// and we don't want the file to change based on where it's being generated,
		// because for example linking to a local package would change the contents
		const ts_contents = `
			// generated by ${basename(import.meta.filename)} - do not edit

			import type {RepoJson} from '${repo_specifier}';

			import json from './repos.json' with {type: 'json'};

			export const repos_json: Array<RepoJson> = json as unknown as Array<RepoJson>;
		`;
		// TODO think about possibly using the `gen` functionality in this task, not sure what the API design could look like
		const formatted_ts = await format_file(ts_contents, {filepath: outfile_ts});
		const existing_ts = existsSync(outfile_ts) ? await readFile(outfile_ts, 'utf8') : '';
		if (existing_ts === formatted_ts) {
			log.info(`no changes to ${print_path(outfile_ts)}`);
		} else {
			log.info(`writing changes to ${print_path(outfile_ts)}`);
			await writeFile(outfile_ts, formatted_ts);
		}

		if (json_changed) {
			await invoke_task('gen');
		}

		const changed = await cache.save();
		if (changed) {
			log.info('repos cache updated');
		} else {
			log.info('repos cache did not change');
		}
	},
};
